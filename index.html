<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="theme-color" content="#f0ede6">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<title>briefing — your daily reddit digest</title>
<script>
  window.sentryOnLoad = function () {
    Sentry.init({
      tracesSampleRate: 1.0,
    });
  };
</script>
<script
  src="https://js.sentry-cdn.com/19ba8e5c6dd9277086223e3bb1818223.min.js"
  crossorigin="anonymous"
  data-lazy="no"
></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #f0ede6;
    --surface: #e6e2d9;
    --border: #1a1a1a;
    --text-primary: #1a1a1a;
    --text-secondary: #555;
    --text-muted: #888;
    --accent: #5a2dff;
    --accent-bg: #5a2dff15;
    /* Type scale — perfect fourth (1.333) */
    --text-xs: 10px;    /* labels, meta */
    --text-sm: 13px;    /* body, UI */
    --text-md: 18px;    /* sub-headers */
    --text-lg: 24px;    /* post titles */
    --text-xl: 32px;    /* logo */
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { background: var(--bg); }

  body {
    background: var(--bg);
    color: var(--text-primary);
    font-family: 'Space Mono', monospace;
    line-height: 1.5;
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
    padding-bottom: env(safe-area-inset-bottom);
  }

  .app { max-width: 700px; margin: 0 auto; padding: 0 16px; padding-top: 90px; }

  header {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 100;
    background: var(--bg);
    border-bottom: 3px solid var(--border);
    padding-top: env(safe-area-inset-top, 0px);
  }
  .header-inner { max-width: 700px; margin: 0 auto; padding: 10px 16px 8px; }
  .header-top { display: flex; justify-content: space-between; align-items: flex-start; }
  .logo {
    font-family: 'Libre Baskerville', serif;
    font-size: var(--text-xl); font-weight: 700; font-style: italic;
    letter-spacing: -0.03em; text-transform: uppercase;
  }
  .header-meta {
    font-size: var(--text-xs); color: var(--text-muted); margin-top: 2px;
    text-transform: uppercase; letter-spacing: 0.12em;
  }
  .header-actions { display: flex; gap: 4px; }
  .btn-small {
    font-family: 'Space Mono', monospace;
    font-size: 9px; padding: 5px 8px;
    border: 2px solid var(--border); background: transparent;
    cursor: pointer; text-transform: uppercase;
    letter-spacing: 0.05em; font-weight: 700;
  }
  .btn-small:hover { background: var(--border); color: var(--bg); }
  .btn-icon {
    width: 30px; height: 30px;
    border: 2px solid var(--border); background: transparent;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
  }
  .btn-icon:hover { background: var(--border); color: var(--bg); }

  .settings { overflow: hidden; max-height: 0; opacity: 0; transition: max-height 0.35s ease, opacity 0.25s ease; }
  .settings.open { max-height: 800px; opacity: 1; }
  .settings-inner { padding: 10px 0 4px; }
  .setting-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
  .setting-label { font-size: 9px; color: var(--text-muted); min-width: 80px; text-transform: uppercase; letter-spacing: 0.1em; }
  .setting-options { display: flex; gap: 3px; flex-wrap: wrap; }
  .pill {
    font-family: 'Space Mono', monospace; font-size: 9px; padding: 3px 7px;
    border: 2px solid transparent; background: transparent;
    color: var(--text-secondary); cursor: pointer; text-transform: uppercase; font-weight: 700;
  }
  .pill:hover { color: var(--text-primary); }
  .pill.active { color: var(--text-primary); border-color: var(--border); background: var(--surface); }

  .subreddit-input-row { display: flex; gap: 6px; margin-top: 4px; }
  .subreddit-input {
    flex: 1; font-family: 'Space Mono', monospace; font-size: 11px;
    padding: 5px 8px; border: 2px solid var(--border); background: transparent; outline: none;
  }
  .subreddit-input:focus { background: var(--surface); }
  .subreddit-input::placeholder { color: var(--text-muted); }

  .sub-tags { display: flex; gap: 4px; flex-wrap: wrap; padding: 8px 0 4px; }
  .sub-tag {
    font-family: 'Space Mono', monospace; font-size: 8px; padding: 2px 5px;
    border: 1.5px solid; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
  }
  .sub-tag .remove-sub { margin-left: 3px; cursor: pointer; opacity: 0.5; }
  .sub-tag .remove-sub:hover { opacity: 1; }

  .loading-state { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 50vh; gap: 16px; }
  .spinner { width: 20px; height: 20px; border: 3px solid var(--surface); border-top-color: var(--border); border-radius: 50%; animation: spin 0.6s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.1em; }

  .error-banner { margin: 12px 0; padding: 10px; border: 2px solid var(--border); font-size: 11px; background: #ff000010; }

  .post-card { padding: 18px 0; border-bottom: 2px solid var(--border); animation: fadeUp 0.3s ease both; transition: opacity 0.4s ease; }
  .post-card:last-child { border-bottom: none; }
  .post-card.read { opacity: 0.2; }
  @keyframes fadeUp { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

  .post-layout { display: flex; gap: 12px; align-items: flex-start; }
  .post-score { display: flex; flex-direction: column; align-items: center; min-width: 44px; padding-top: 2px; }
  .post-score .arrow { width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 6px solid var(--accent); margin-bottom: 3px; }
  .post-score .num { font-size: 11px; font-weight: 700; }
  .post-content { flex: 1; min-width: 0; }
  .post-meta { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-bottom: 4px; }
  .post-sub {
    font-size: 8px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em;
    padding: 1px 5px; border: 1.5px solid var(--accent); color: var(--accent);
  }
  .post-flair { font-size: 8px; color: var(--text-muted); border: 1px solid var(--text-muted); padding: 1px 4px; text-transform: uppercase; }
  .post-time { font-size: 9px; color: var(--text-muted); }
  .post-title {
    font-family: 'Libre Baskerville', Georgia, serif;
    font-size: var(--text-lg); font-weight: 700; line-height: 1.3;
    color: var(--text-primary); text-decoration: none; display: block; margin-bottom: 6px;
  }
  .post-title:hover { color: var(--accent); }
  .post-card.read .post-title { color: var(--text-muted); }
  .post-selftext { font-size: var(--text-sm); color: var(--text-secondary); line-height: 1.6; margin-bottom: 6px; padding-left: 10px; border-left: 3px solid var(--accent); }
  .post-thumbnail { margin: 6px 0; max-width: 100%; max-height: 280px; object-fit: cover; border: 2px solid var(--border); }
  .post-footer { display: flex; align-items: center; gap: 12px; }
  .post-comments { font-size: 9px; color: var(--text-muted); display: flex; align-items: center; gap: 4px; text-decoration: none; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700; }
  .post-comments:hover { color: var(--text-primary); }
  .post-link { font-size: 9px; color: var(--text-muted); text-decoration: none; }
  .post-link:hover { color: var(--accent); }

  .end-marker { text-align: center; padding: 40px 0 60px; font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.15em; }

  .completion { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 50vh; text-align: center; padding: 40px 20px; animation: fadeUp 0.6s ease; }
  .completion-icon { width: 56px; height: 56px; border: 3px solid var(--border); display: flex; align-items: center; justify-content: center; margin-bottom: 20px; animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); }
  @keyframes popIn { from { transform: scale(0.4); opacity: 0; } to { transform: scale(1); opacity: 1; } }
  .completion h2 { font-family: 'Libre Baskerville', serif; font-size: var(--text-xl); font-weight: 700; font-style: italic; margin-bottom: 8px; }
  .completion p { font-size: 11px; color: var(--text-secondary); max-width: 340px; line-height: 1.6; margin-bottom: 20px; }
  .completion button { font-family: 'Space Mono', monospace; font-size: 10px; padding: 8px 20px; border: 2px solid var(--border); background: transparent; cursor: pointer; text-transform: uppercase; font-weight: 700; }
  .completion button:hover { background: var(--border); color: var(--bg); }

  .empty-state { text-align: center; padding: 80px 20px; }
  .empty-state h3 { font-family: 'Libre Baskerville', serif; font-size: 18px; font-weight: 700; margin-bottom: 8px; }
  .empty-state p { font-size: 11px; color: var(--text-secondary); max-width: 360px; margin: 0 auto; line-height: 1.6; }

  @media (max-width: 480px) {
    .post-title { font-size: 20px; }
    .logo { font-size: 26px; }
    .post-score { min-width: 36px; }
    .app { padding-top: 85px; }
  }
</style>
</head>
<body>
<div class="app" id="app"></div>

<script>
// ═══════════════════════════════════════════
// SENTRY — initialized via loader script in <head>
// ═══════════════════════════════════════════

// Helper to add Sentry breadcrumbs
function track(category, message, data = {}) {
  if (window.Sentry) {
    Sentry.addBreadcrumb({ category, message, data, level: 'info' });
  }
}

// ═══════════════════════════════════════════
// CONFIG — Edit your subreddits here!
// ═══════════════════════════════════════════
const DEFAULT_SUBS = [
  "webdev",
  "science",
  "space",
  "technology",
  "90s",
  "accidentalrenaissance",
  "analog",
  "animalsbeingbros",
  "animalsbeingderps",
  "anticonsumption",
  "apple",
  "bayarea",
  "boardgames",
  "coolguides",
  "damnthatsinteresting",
  "dataisbeautiful",
  "historyporn",
  "humansbeingbros",
  "interestingasfuck",
  "isthisai",
  "jeffrosenstock",
  "law",
  "mademesmile",
  "millennials",
  "moodcamera",
  "mothershiprpg",
  "moviedetails",
  "murderedbywords",
  "n64",
  "nasa",
  "newgirl",
  "natureisfuckinglit",
  "obscuremusicthatslaps",
  "oceansarefuckinglit",
  "oddlysatisfying",
  "oldschoolcool",
  "outoftheloop",
  "sanfrancisco",
  "severanceappletvplus",
  "streetphotography",
  "thatsinsane",
  "thedepthsbelow",
  "theydidthemath",
  "todayilearned",
  "tvdetails",
  "twinpeaks",
  "underratedmovies",
  "woahdude",
  "worldnews",
  "design",
];

const SUB_COLORS = [
  "#007575", "#936119", "#c0304a", "#26754f",
  "#7040c0", "#a3511b", "#1e6aa7", "#a83070",
  "#3e7328", "#88641c", "#3060a0", "#b83030",
];

function getSubColor(sub) {
  let hash = 0;
  for (let i = 0; i < sub.length; i++) hash = sub.charCodeAt(i) + ((hash << 5) - hash);
  return SUB_COLORS[Math.abs(hash) % SUB_COLORS.length];
}

// ═══════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════
let state = {
  subreddits: JSON.parse(localStorage.getItem('briefing_subs') || 'null') || [...DEFAULT_SUBS],
  posts: [],
  readPosts: new Set(JSON.parse(localStorage.getItem('briefing_read') || '[]')),
  loading: false,
  error: null,
  settingsOpen: false,
  sortBy: localStorage.getItem('briefing_sort') || 'score',
  digestSize: 25,
  timeRange: localStorage.getItem('briefing_time') || 'day',
  isComplete: false,
  lastFetch: localStorage.getItem('briefing_lastfetch') || null,
};

function saveSubs() { localStorage.setItem('briefing_subs', JSON.stringify(state.subreddits)); }
function saveRead() { localStorage.setItem('briefing_read', JSON.stringify([...state.readPosts])); }
function savePrefs() {
  localStorage.setItem('briefing_sort', state.sortBy);
  localStorage.setItem('briefing_limit', state.digestSize);
  localStorage.setItem('briefing_time', state.timeRange);
}

// ═══════════════════════════════════════════
// FETCH REDDIT DATA
// ═══════════════════════════════════════════

// Your own Cloudflare Worker proxy
const PROXY_BASE = 'https://reddit-proxy.steven-413.workers.dev';
const CACHE_TTL = 15 * 60 * 1000; // 15 minutes

function parsePosts(data) {
  return (data.data?.children || []).map(child => {
    const d = child.data;
    return {
      id: d.id,
      subreddit: d.subreddit,
      title: d.title,
      author: d.author,
      score: d.score,
      comments: d.num_comments,
      created: d.created_utc,
      selftext: (d.selftext || '').slice(0, 300),
      url: d.url,
      permalink: `https://www.reddit.com${d.permalink}`,
      thumbnail: (d.thumbnail && d.thumbnail.startsWith('http'))
        ? d.thumbnail : null,
      preview: d.preview?.images?.[0]?.source?.url?.replace(/&amp;/g, '&') || null,
      post_hint: d.post_hint || null,
      flair: d.link_flair_text || null,
      is_self: d.is_self,
      domain: d.domain,
    };
  });
}

async function fetchMultiSub(subs, timeRange) {
  // Reddit supports /r/sub1+sub2+sub3/top.json — combine up to ~10 per request
  const combined = subs.join('+');
  const path = timeRange === 'hot'
    ? `/r/${combined}/hot.json?limit=${subs.length * 5}&raw_json=1`
    : `/r/${combined}/top.json?t=${timeRange}&limit=${subs.length * 5}&raw_json=1`;

  const resp = await fetch(PROXY_BASE + path);
  if (!resp.ok) throw new Error(`Batch fetch failed: ${resp.status}`);
  const data = await resp.json();
  return parsePosts(data);
}

async function fetchAllPosts(forceRefresh = false) {
  // Check cache first — render from cache immediately
  if (!forceRefresh) {
    const cached = localStorage.getItem('briefing_cache');
    const cachedTime = localStorage.getItem('briefing_cache_time');
    const cachedSubs = localStorage.getItem('briefing_cache_subs');
    const cachedRange = localStorage.getItem('briefing_cache_range');
    if (cached && cachedTime &&
        Date.now() - parseInt(cachedTime) < CACHE_TTL &&
        cachedSubs === JSON.stringify(state.subreddits) &&
        cachedRange === state.timeRange) {
      state.posts = JSON.parse(cached);
      state.loading = false;
      state.lastFetch = new Date(parseInt(cachedTime)).toISOString();
      track('fetch', 'cache_hit', { age: Math.round((Date.now() - parseInt(cachedTime)) / 1000) + 's', posts: state.posts.length });
      render();
      return;
    }
  }

  const fetchStart = Date.now();
  const previousIds = new Set(state.posts.map(p => p.id));

  state.loading = true;
  state.error = null;
  if (state.posts.length === 0) render();

  try {
    const BATCH_SIZE = 10;
    const batches = [];
    for (let i = 0; i < state.subreddits.length; i += BATCH_SIZE) {
      batches.push(state.subreddits.slice(i, i + BATCH_SIZE));
    }

    const PARALLEL = 3;
    const results = [];
    for (let i = 0; i < batches.length; i += PARALLEL) {
      const chunk = batches.slice(i, i + PARALLEL);
      state.loadingProgress = `${Math.min((i + PARALLEL) * BATCH_SIZE, state.subreddits.length)}/${state.subreddits.length} subs`;
      if (state.posts.length === 0) render();
      const chunkResults = await Promise.allSettled(
        chunk.map(batch => fetchMultiSub(batch, state.timeRange))
      );
      chunkResults.forEach(r => {
        if (r.status === 'fulfilled') results.push(...r.value);
      });
    }
    state.loadingProgress = null;

    const seen = new Set();
    const newPosts = results.filter(p => {
      if (seen.has(p.id)) return false;
      seen.add(p.id);
      return true;
    });

    const genuinelyNew = newPosts.filter(p => !previousIds.has(p.id)).length;
    const fetchDuration = Date.now() - fetchStart;

    state.posts = newPosts;
    state.lastFetch = new Date().toISOString();
    localStorage.setItem('briefing_cache', JSON.stringify(state.posts));
    localStorage.setItem('briefing_cache_time', Date.now().toString());
    localStorage.setItem('briefing_cache_subs', JSON.stringify(state.subreddits));
    localStorage.setItem('briefing_cache_range', state.timeRange);
    localStorage.setItem('briefing_lastfetch', state.lastFetch);

    track('fetch', 'fetch_complete', {
      duration: fetchDuration + 'ms',
      totalPosts: newPosts.length,
      newPosts: genuinelyNew,
      subs: state.subreddits.length,
      forced: forceRefresh,
    });

  } catch (e) {
    state.error = e.message;
    track('fetch', 'fetch_error', { error: e.message });
    if (window.Sentry) Sentry.captureException(e);
  }

  state.loading = false;
  render();
}

// ═══════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════
function formatScore(n) {
  if (n >= 100000) return (n / 1000).toFixed(0) + 'k';
  if (n >= 1000) return (n / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
  return n;
}

function timeAgo(utc) {
  const diff = Date.now() / 1000 - utc;
  if (diff < 3600) return Math.floor(diff / 60) + 'm';
  if (diff < 86400) return Math.floor(diff / 3600) + 'h';
  return Math.floor(diff / 86400) + 'd';
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function getSortedPosts() {
  const MAX_PER_SUB = 2;

  // Only show unread posts
  const unread = state.posts.filter(p => !state.readPosts.has(p.id));

  // If sorting by 'new', skip normalization — just enforce the sub cap
  if (state.sortBy === 'new') {
    const subCount = {};
    return [...unread]
      .sort((a, b) => b.created - a.created)
      .filter(p => {
        subCount[p.subreddit] = (subCount[p.subreddit] || 0) + 1;
        return subCount[p.subreddit] <= MAX_PER_SUB;
      })
      .slice(0, state.digestSize);
  }

  // Calculate per-subreddit average score for normalization (using ALL posts for accurate averages)
  const subScores = {};
  state.posts.forEach(p => {
    if (!subScores[p.subreddit]) subScores[p.subreddit] = { total: 0, count: 0 };
    subScores[p.subreddit].total += p.score;
    subScores[p.subreddit].count += 1;
  });

  const subAvg = {};
  for (const [sub, data] of Object.entries(subScores)) {
    subAvg[sub] = data.count > 0 ? data.total / data.count : 1;
  }

  const scored = unread.map(p => {
    const avg = subAvg[p.subreddit] || 1;
    const rawFactor = Math.log10(Math.max(p.score, 1)) / 5;
    const field = state.sortBy === 'comments' ? p.comments : p.score;
    const fieldAvg = state.sortBy === 'comments'
      ? (subScores[p.subreddit]?.count > 0
          ? state.posts.filter(x => x.subreddit === p.subreddit).reduce((s, x) => s + x.comments, 0) / subScores[p.subreddit].count
          : 1)
      : avg;
    const fieldNorm = field / Math.max(fieldAvg, 1);

    // Time decay: boost newer posts, penalize older ones
    // A post 1hr old gets ~1.0, 6hrs gets ~0.6, 12hrs gets ~0.45, 24hrs gets ~0.35
    const hoursOld = Math.max((Date.now() / 1000 - p.created) / 3600, 0.5);
    const timeFactor = 1 / Math.pow(hoursOld, 0.4);

    // Blend: 50% normalized score, 20% raw magnitude, 30% time freshness
    const blended = fieldNorm * 0.5 + rawFactor * 0.2 + timeFactor * 3 * 0.3;
    return { ...p, _blended: blended };
  });

  scored.sort((a, b) => b._blended - a._blended);

  const subCount = {};
  return scored.filter(p => {
    subCount[p.subreddit] = (subCount[p.subreddit] || 0) + 1;
    return subCount[p.subreddit] <= MAX_PER_SUB;
  }).slice(0, state.digestSize);
}

// ═══════════════════════════════════════════
// ACTIONS
// ═══════════════════════════════════════════
function markRead(id) {
  state.readPosts.add(id);
  saveRead();
  track('engagement', 'post_clicked', { postId: id });
  const el = document.querySelector(`.post-card[data-post-id="${id}"]`);
  if (el) el.classList.add('read');
  // Update header count
  updateHeaderCount();
}

function markAllRead() {
  const count = state.posts.length;
  state.posts.forEach(p => state.readPosts.add(p.id));
  saveRead();
  track('engagement', 'mark_all_read', { postCount: count });
  render();
}

function checkCompletion() {
  const posts = getSortedPosts();
  if (posts.length > 0 && posts.every(p => state.readPosts.has(p.id))) {
    setTimeout(() => { state.isComplete = true; render(); }, 600);
  }
}

function resetDigest() {
  state.readPosts.clear();
  state.isComplete = false;
  saveRead();
  fetchAllPosts(true);
}

function addSubreddit(name) {
  const clean = name.trim().toLowerCase().replace(/^r\//, '');
  if (clean && !state.subreddits.includes(clean)) {
    state.subreddits.push(clean);
    saveSubs();
    render();
  }
}

function removeSubreddit(name) {
  state.subreddits = state.subreddits.filter(s => s !== name);
  saveSubs();
  render();
}

function setSortBy(val) {
  state.sortBy = val;
  savePrefs();
  render();
}

function setDigestSize(val) {
  state.digestSize = val;
  savePrefs();
  render();
}

function setTimeRange(val) {
  state.timeRange = val;
  savePrefs();
  render();
}

function toggleSettings() {
  state.settingsOpen = !state.settingsOpen;
  render();
}

// ═══════════════════════════════════════════
// RENDER
// ═══════════════════════════════════════════
function render() {
  const posts = getSortedPosts();
  const now = new Date();
  const dateStr = now.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

  const unreadCount = posts.length;

  // Show when data was last fetched
  let fetchInfo = '';
  if (state.lastFetch) {
    const ago = Date.now() - new Date(state.lastFetch).getTime();
    if (ago < 60000) fetchInfo = 'just now';
    else if (ago < 3600000) fetchInfo = Math.floor(ago / 60000) + 'm ago';
    else fetchInfo = Math.floor(ago / 3600000) + 'h ago';
  }

  let html = `
    <header>
      <div class="header-inner">
        <div class="header-top">
          <div>
            <div class="logo">briefing</div>
            <div class="header-meta">${dateStr} · ${unreadCount} new${fetchInfo ? ' · updated ' + fetchInfo : ''}</div>
          </div>
          <div class="header-actions">
            <button class="btn-small" onclick="markAllRead()">mark all read</button>
            <button class="btn-small" onclick="fetchAllPosts(true)">refresh</button>
            <button class="btn-icon" onclick="toggleSettings()">
              <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="20" y2="18"/>
                <circle cx="8" cy="6" r="2" fill="currentColor"/><circle cx="16" cy="12" r="2" fill="currentColor"/><circle cx="10" cy="18" r="2" fill="currentColor"/>
              </svg>
            </button>
          </div>
        </div>

        <div class="settings ${state.settingsOpen ? 'open' : ''}">
          <div class="settings-inner">
            <div class="setting-row">
              <span class="setting-label">sort by</span>
              <div class="setting-options">
                ${[['score','top'],['comments','discussed'],['new','newest']].map(([val, label]) =>
                  `<button class="pill ${state.sortBy===val?'active':''}" onclick="setSortBy('${val}')">${label}</button>`
                ).join('')}
              </div>
            </div>
            <div class="setting-row">
              <span class="setting-label">time range</span>
              <div class="setting-options">
                ${[['hot','hot'],['day','today'],['week','this week']].map(([val, label]) =>
                  `<button class="pill ${state.timeRange===val?'active':''}" onclick="setTimeRange('${val}')">${label}</button>`
                ).join('')}
              </div>
            </div>
            <div class="setting-row">
              <span class="setting-label">subreddits</span>
              <div class="subreddit-input-row" style="flex:1">
                <input class="subreddit-input" id="subInput" type="text"
                  placeholder="add subreddit, e.g. machinelearning"
                  onkeydown="if(event.key==='Enter'){addSubreddit(this.value);this.value='';}" />
                <button class="btn-small" onclick="const i=document.getElementById('subInput');addSubreddit(i.value);i.value='';">add</button>
              </div>
            </div>
            <div class="sub-tags">
              ${state.subreddits.map(sub => {
                const c = getSubColor(sub);
                return `<span class="sub-tag" style="background:${c}15;color:${c}">
                  r/${escapeHtml(sub)}<span class="remove-sub" onclick="removeSubreddit('${escapeHtml(sub)}')">&times;</span>
                </span>`;
              }).join('')}
            </div>
          </div>
        </div>
      </div>
    </header>
  `;

  // Loading
  if (state.loading) {
    html += `<div class="loading-state">
      <div class="spinner"></div>
      <span class="loading-text">fetching your digest…${state.loadingProgress ? ` (${state.loadingProgress})` : ''}</span>
    </div>`;
    document.getElementById('app').innerHTML = html;
    return;
  }

  // Error
  if (state.error) {
    html += `<div class="error-banner">${escapeHtml(state.error)}</div>`;
  }

  // All caught up screen — only when mark all read was used
  if (!state.loading && posts.length > 0 && unreadCount === 0 && !state.error) {
    // Still render the header, then show caught up
    html += `<div class="completion">
      <div class="completion-icon">
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="var(--text-primary)" stroke-width="2.5" stroke-linecap="round">
          <path d="M20 6L9 17l-5-5"/>
        </svg>
      </div>
      <h2>You're all caught up.</h2>
      <p>Nothing new from your ${state.subreddits.length} subreddits. Check back later.</p>
      <button onclick="fetchAllPosts(true)">check now</button>
    </div>`;
    document.getElementById('app').innerHTML = html;
    return;
  }

  // Empty state — no posts fetched at all
  if (!state.loading && state.posts.length === 0 && !state.error) {
    html += `<div class="empty-state">
      <h3>No posts yet</h3>
      <p>Hit "refresh" to fetch posts from your subreddits, or add more in settings.</p>
    </div>`;
    document.getElementById('app').innerHTML = html;
    return;
  }

  // Post cards
  posts.forEach((post, i) => {
    const c = getSubColor(post.subreddit);

    html += `
    <div class="post-card" data-post-id="${post.id}" style="animation-delay:${i * 40}ms">
      <div class="post-layout">
        <div class="post-score">
          <div class="arrow" style="color:${c}"></div>
          <span class="num" style="color:${c}">${formatScore(post.score)}</span>
        </div>
        <div class="post-content">
          <div class="post-meta">
            <span class="post-sub" style="background:${c}15;color:${c}">r/${escapeHtml(post.subreddit)}</span>
            ${post.flair ? `<span class="post-flair">${escapeHtml(post.flair)}</span>` : ''}
            <span class="post-time">${timeAgo(post.created)} · u/${escapeHtml(post.author)}</span>
          </div>
          <a class="post-title" href="${post.is_self ? escapeHtml(post.permalink) : escapeHtml(post.url)}" target="_blank" rel="noopener" onclick="markRead('${post.id}')">${escapeHtml(post.title)}</a>
          ${post.selftext ? `<div class="post-selftext" style="border-color:${c}40">${escapeHtml(post.selftext)}${post.selftext.length >= 300 ? '…' : ''}</div>` : ''}
          ${post.preview && (post.post_hint === 'image' || post.post_hint === 'rich:video' || post.post_hint === 'link') ? `<a href="${escapeHtml(post.permalink)}" target="_blank" rel="noopener" onclick="markRead('${post.id}')"><img class="post-thumbnail" src="${escapeHtml(post.preview)}" alt="" loading="lazy"></a>` : (post.thumbnail && !post.selftext ? `<a href="${escapeHtml(post.permalink)}" target="_blank" rel="noopener" onclick="markRead('${post.id}')"><img class="post-thumbnail" src="${escapeHtml(post.thumbnail)}" alt="" loading="lazy"></a>` : '')}
          <div class="post-footer">
            <a class="post-comments" href="${escapeHtml(post.permalink)}" target="_blank" rel="noopener">
              <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
              </svg>
              ${post.comments} comments
            </a>
            ${!post.is_self ? `<a class="post-link" href="${escapeHtml(post.url)}" target="_blank" rel="noopener">${escapeHtml(post.domain)}</a>` : ''}
          </div>
        </div>
      </div>
    </div>`;
  });

  html += `<div class="end-marker">— end of digest —</div>`;

  document.getElementById('app').innerHTML = html;
  attachScrollObserver();
}

// ═══════════════════════════════════════════
// SCROLL-BASED AUTO-READ
// ═══════════════════════════════════════════
let scrollObserver = null;

function attachScrollObserver() {
  // Disconnect previous observer
  if (scrollObserver) scrollObserver.disconnect();

  scrollObserver = new IntersectionObserver((entries) => {
    let changed = false;
    entries.forEach(entry => {
      const id = entry.target.dataset.postId;
      if (!id) return;
      if (!entry.isIntersecting && entry.boundingClientRect.bottom < 100) {
        if (!state.readPosts.has(id)) {
          state.readPosts.add(id);
          entry.target.classList.add('read');
          changed = true;
        }
      }
    });
    if (changed) {
      saveRead();
      updateHeaderCount();
    }
  }, {
    threshold: 0,
    rootMargin: '0px 0px 0px 0px'
  });

  document.querySelectorAll('.post-card:not(.read)').forEach(el => {
    scrollObserver.observe(el);
  });
}

function updateHeaderCount() {
  const unread = state.posts.filter(p => !state.readPosts.has(p.id)).length;
  const meta = document.querySelector('.header-meta');
  if (meta) {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
    let fetchInfo = '';
    if (state.lastFetch) {
      const ago = Date.now() - new Date(state.lastFetch).getTime();
      if (ago < 60000) fetchInfo = 'just now';
      else if (ago < 3600000) fetchInfo = Math.floor(ago / 60000) + 'm ago';
      else fetchInfo = Math.floor(ago / 3600000) + 'h ago';
    }
    meta.textContent = `${dateStr} · ${unread} new${fetchInfo ? ' · updated ' + fetchInfo : ''}`;
  }
}

// ═══════════════════════════════════════════
// SCROLL POSITION SAVE/RESTORE
// ═══════════════════════════════════════════
window.addEventListener('scroll', () => {
  sessionStorage.setItem('briefing_scroll', window.scrollY);
}, { passive: true });

function restoreScroll() {
  const saved = sessionStorage.getItem('briefing_scroll');
  if (saved) {
    requestAnimationFrame(() => window.scrollTo(0, parseInt(saved)));
  }
}

// ═══════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════
render();
fetchAllPosts().then(() => restoreScroll());
</script>
</body>
</html>
